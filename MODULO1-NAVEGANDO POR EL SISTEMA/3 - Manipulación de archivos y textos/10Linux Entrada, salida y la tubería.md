> [!TIP]  
> [Ver video](https://youtu.be/F1jZaNM4U7k)

Al igual que en Windows, tenemos tres flujos de E/S diferentes: salida estándar, entrada estándar y error estándar. ¿Recuerdas el ejemplo estándar en la última lección? Bueno, el mismo concepto se aplica en Linux. Hacemos `echo` del texto "woof" aquí, pero en lugar de enviarlo a nuestra pantalla en forma predeterminada, vamos a redirigir la salida a un archivo usando el operador de redireccionamiento estándar. Vamos a verificarlo... y ahí está. Esto sobrescribe cualquier archivo llamado `dog.text` con el contenido "woof". Si no queremos sobrescribir un archivo existente, podemos utilizar el operador "agregar" o `>>`. Entonces, `echo "woof" >> dog.txt`. Podríamos verificarlo. Ahí está.

Un operador de redireccionamiento del que hablamos en la lección de Windows, pero del que no mostramos un ejemplo, era el operador de redireccionamiento de entrada estándar. El operador de redireccionamiento de entrada estándar se marca con un signo "menos que" (`<`). En lugar de obtener entrada desde el teclado, podemos obtener entrada de archivos como este. Este comando es exactamente el mismo que `cat file_input`. La diferencia aquí es que no estamos usando más nuestra entrada de teclado, estamos usando el archivo como entrada estándar.

Por último, de manera similar a Windows, el último operador de redireccionamiento del que hablaremos es el error estándar. El error estándar muestra los mensajes de error que puedes obtener usando el operador de redireccionamiento "2 mayor que" (`2>`). Al igual que en Windows, `2>` se usa para indicar error estándar. Entonces, para redirigir solo los mensajes de error de alguna salida, puedes usar algo como esto: `ls /dir/fake_dir 2> error_output.txt`. Ahora, si veo ese nuevo documento, podemos ver el mensaje de error en `error_output.txt`.

¿Recuerdas la variable `$null` que usamos en Windows para arrojar la salida no deseada en un agujero negro metafórico? También tenemos algo así en Linux. Hay un archivo especial en Linux llamado `/dev/null`. Supongamos que queremos filtrar los mensajes de error en un archivo y solo quiero ver los mensajes de salida estándar. Podríamos hacer algo como esto: `ls /dir/fake_dir 2> /dev/null`. Ahora, se filtran los mensajes de error de nuestra salida.

¿Recuerdas cómo hablamos de tomar la salida de un comando y usarla como la entrada de otro comando, con la barra vertical de Windows? Bueno, lo mismo existe en Linux. El comando `|` nos permite hacer esto. Supongamos que queremos ver en qué subdirectorios del directorio `/etc` contiene la palabra Bluetooth. Podemos hacer algo como esto: `ls -la /etc | grep Bluetooth`. Estamos usando la barra vertical para tomar la salida de `ls -la /etc` y aplicamos la barra vertical o la enviamos al comando `grep`. Ahora, sin siquiera examinar el directorio, podemos ver rápidamente si el directorio Bluetooth está aquí. Ahí está.

Viste un esbozo de la potencia de las opciones de redireccionamiento y, a medida que te adentres en el mundo de Linux, las usarás con regularidad. Son herramientas muy valiosas para tener, y ahora son parte de tu juego de herramientas.
