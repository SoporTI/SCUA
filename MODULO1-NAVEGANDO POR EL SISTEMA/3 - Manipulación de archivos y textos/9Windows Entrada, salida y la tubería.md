De acuerdo, conocimos un montón de herramientas individuales y muy poderosas. Son los comandos de uso diario más importantes que necesitarás para trabajar en PowerShell. Ahora, vamos a aprender cómo combinar estas herramientas para hacerlas aún más poderosas.

Ejecutemos el siguiente comando en nuestro directorio Desktop (Escritorio). Luego, lo desglosaremos poco a poco. Voy a ejecutar `cd` en mi directorio Desktop. de acuerdo, uso `echo woof > dog.txt`. Hará un `ls` para revisar nuestro escritorio, y ahora veremos un archivo llamado `dog.txt`. Dentro de ese archivo, deberíamos ver la palabra "woof". Oh, ahí está.

¿Qué ocurre aquí? Vamos a verlo más de cerca, `echo woof`. En PowerShell, `echo` es en realidad un alias para `Write-Output` (salida de escritura). Eso nos da una pista de lo que está ocurriendo. Sabemos que el comando `echo` imprime nuestra entrada de teclado en la pantalla. Pero ¿cómo funciona esto?

Cada proceso de Windows y cada comando de PowerShell pueden tomar una entrada y pueden producir una salida. Para hacer esto, usamos algo conocido como flujos de E/S o flujos de entrada/salida. Cada proceso en Windows tiene tres flujos diferentes: entrada estándar, salida estándar y error estándar. Es útil pensar en estos flujos como verdaderas corrientes de agua en un río. Proporcionas una entrada a un proceso agregando cosas al flujo de entrada estándar que fluye hacia el proceso. Cuando el proceso crea salida, agrega datos al flujo de salida estándar, que fluye fuera del proceso.

En la CLI, la entrada que proporcionas a través del teclado va al flujo de entrada estándar del proceso con el que estás interactuando. Esto sucede ya sea en PowerShell, un editor de texto o cualquier otra cosa. Luego, el proceso se vuelve a comunicar contigo colocando datos en el flujo de salida estándar, que la CLI escribe en la pantalla que estás mirando.

Ahora, ¿y si en lugar de ver la salida del comando en la pantalla, quisiéramos guardarla en un archivo? El símbolo "mayor que" (`>`) es algo que llamamos un operador de redireccionamiento que nos permite cambiar adónde queremos que vaya nuestra salida estándar. En lugar de enviar la salida estándar a la pantalla, podemos enviarla a un archivo. Si el archivo existe, lo sobrescribirá por nosotros. De lo contrario, creará un nuevo archivo. Si no queremos sobrescribir un archivo existente, hay otro operador operador de redireccionamiento que podemos usar para agregar información: `>>`. Vamos a verlo en acción. `echo woof >> dog.txt`. Ahora, si miro mi archivo `dog.txt` de nuevo, podemos ver que "woof" se agregó de nuevo.

Pero ¿y si quisiéramos enviar la salida de un comando a la entrada de otro comando? Para esto, vamos a utilizar otro operador, la barra vertical (`|`). Primero, veamos qué hay en este archivo. `cat words.txt`. Mira eso, es una lista de palabras. Ahora, ¿y si solo queremos enumerar las palabras que contienen la string "st"? Podemos hacer lo mismo que antes y usar `Select-String` o `sls` en el archivo directamente. Esta vez, vamos a usar la barra vertical para pasar la salida de `cat` a la entrada de `Select-string`. Entonces: `cat words.txt | select-string st`. Y ahora, podemos ver una lista de palabras con la string "st". Para unir las cosas, podemos usar el redireccionamiento de salida para poner nuestra nueva lista en un archivo. Entonces ahora, `> y luego un nuevo archivo llamado st_words.txt`. Ahora, si hago `cat st.words.txt`, sí, ahí está. Eso es solo un ejemplo muy básico de cómo puedes tomar varias herramientas simples y combinarlas para realizar tareas complejas.

Bien, ahora vamos a conocer al último redireccionador de E/S, el error estándar. ¿Recuerdas cuando intentamos eliminar un archivo de sistema restringido anteriormente y recibimos un error que decía "permiso denegado"? Repasemos eso una vez más. Esta vez, voy a eliminar otro archivo protegido: `rm secure_file`. Vemos errores que se supone que deben aparecer. Pero ¿y si no quisiéramos ver estos errores?

Resulta que podemos redirigir la salida de los mensajes de error en un flujo de salida diferente llamada error estándar. El operador de redireccionamiento se puede utilizar para redirigir cualquiera de los flujos de salida, pero tenemos que decir qué flujo redirigir. Por lo tanto, vamos a escribir, `rm secure_file 2> errors.txt`. Si miro a `errors.txt`, puedo ver el mensaje de error que acabamos de recibir. Entonces, ¿qué significa el `2`? Todos los flujos de salida están numerados. `1` es para la salida estándar, que es la salida que normalmente ves, y `2` es para el error estándar o los mensajes de error. Aviso: PowerShell en realidad tiene unos cuantos flujos más que no vamos a usar en esta lección. Pero se los puede redirigir de la misma manera. Puedes aprender más sobre ellos en la lectura complementaria, justo después de este video.

Cuando usamos `2>`, le estamos diciendo a PowerShell que redirija el flujo de error estándar al archivo en lugar de la salida estándar. ¿Y si no nos importan los mensajes de error, pero tampoco queremos ponerlos en un archivo? Con los operadores de redireccionamiento que recién aprendimos, realmente podemos filtrar estos mensajes de error. En PowerShell, podemos hacerlo redireccionando el error estándar a `$null`. ¿Qué es `$null`? Bueno, es nada. No, de verdad. Es una variable especial que contiene la definición de "nada". Puedes considerarlo un agujero negro a fines de redireccionamiento. Vamos a redirigir los mensajes de error esta vez a `$null`. `rm secure_file 2> $ null`. Ahora, se filtran los mensajes de error de nuestra salida.

Todavía hay mucho más para aprender si estás interesado. Prueba `Get-Help about_redirection` en PowerShell para ver más detalles. Puede llevar un poco de tiempo aprender a usar los operadores de redireccionamiento. No te preocupes, es totalmente normal. Una vez que comiences a acostumbrarte a ellos, notarás que tu nivel de habilidades aumenta y tu trabajo se vuelve un poco más fácil. Ahora, vamos a ver el redireccionamiento de la salida en Linux.
